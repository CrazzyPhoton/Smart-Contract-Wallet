{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-ae4d6eab4defed97ede10d1ceadd5107cc978bf6",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/FactoryContractForSmartContractWallet.sol": "project/contracts/FactoryContractForSmartContractWallet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 10000
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC1155/IERC1155.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC1155/IERC1155Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC1155/utils/ERC1155Holder.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165, ERC165} from \"../../../utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/IERC721Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/utils/ERC721Holder.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\n * {IERC721-setApprovalForAll}.\n */\nabstract contract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/FactoryContractForSmartContractWallet.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\nimport \"./SmartContractWallet.sol\";\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/// @title FactoryContractForSmartContractWallet\r\n/// @author Rahul Mayekar (https://github.com/CrazzyPhoton)\r\n/// @notice A factory contract to deploy instances of SmartContractWallet.\r\n/// @dev This contract manages ownership and deployment of SmartContractWallet instances.\r\n\r\ncontract FactoryContractForSmartContractWallet {\r\n    // STATE VARIABLES //\r\n\r\n    /// @notice Address variable to store owner.\r\n    address public owner;\r\n\r\n    /// @notice Boolean to pause and unpause deployment of smart contract wallets.\r\n    bool public isDeploymentPaused;\r\n\r\n    /// @notice Mapping to store smart contract wallets of address.\r\n    mapping(address => address[]) private smartContractWalletsOfAddress;\r\n\r\n    // EVENTS //\r\n\r\n    /// @notice Event emitted when ownership is transferred.\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @notice Event emitted when smart contract wallet is deployed.\r\n    event SmartContractWalletDeployed(\r\n        address indexed smartContractWalletAddress,\r\n        address indexed smartContractWalletOwner\r\n    );\r\n\r\n    // ERRORS //\r\n\r\n    /// @notice Error thrown when caller is not owner.\r\n    error CallerNotOwner(address caller);\r\n\r\n    /// @notice Error thrown when smart contract wallet deployment is paused.\r\n    error DeploymentPaused();\r\n\r\n    /// @notice Error thrown when new owner is zero address.\r\n    error InvalidNewOwner(address zeroAddress);\r\n\r\n    // MODIFIERS //\r\n\r\n    /// @notice Modifier to check whether caller is owner.\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert CallerNotOwner(msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCTOR //\r\n\r\n    /// @notice Constructor called during deployment.\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    // FUNCTIONS //\r\n\r\n    /**\r\n     * @notice Function deploys smart contract wallet.\r\n     *\r\n     * @param _owner    The address of owner.\r\n     * @param _trusteeA The address of trusteeA.\r\n     * @param _trusteeB The address of trusteeB.\r\n     * @param _trusteeC The address of trusteeC.\r\n     */\r\n    function deploySmartContractWallet(\r\n        address _owner,\r\n        address _trusteeA,\r\n        address _trusteeB,\r\n        address _trusteeC\r\n    ) external returns (address, address) {\r\n        if (isDeploymentPaused == true) {\r\n            revert DeploymentPaused();\r\n        }\r\n        SmartContractWallet newSmartContractWallet = new SmartContractWallet(\r\n            _owner,\r\n            _trusteeA,\r\n            _trusteeB,\r\n            _trusteeC\r\n        );\r\n        smartContractWalletsOfAddress[_owner].push(\r\n            address(newSmartContractWallet)\r\n        );\r\n        emit SmartContractWalletDeployed(\r\n            address(newSmartContractWallet),\r\n            _owner\r\n        );\r\n        address smartContractWalletAddress = address(newSmartContractWallet);\r\n        address smartContractWalletOwner = _owner;\r\n        return (smartContractWalletAddress, smartContractWalletOwner);\r\n    }\r\n\r\n    /// @notice Function pauses and unpauses deployment of smart contract wallets.\r\n    function pauseDeployment() external onlyOwner {\r\n        isDeploymentPaused = !isDeploymentPaused;\r\n    }\r\n\r\n    /**\r\n     * @notice Function transfers ownership of the smart contract to a new address.\r\n     *\r\n     * @param newOwner Address of new owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert InvalidNewOwner(address(0));\r\n        }\r\n        address oldOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Function returns smart contract wallets of an address.\r\n     *\r\n     * @param _address The address to be queried for.\r\n     */\r\n    function getSmartContractWalletsOfAddress(\r\n        address _address\r\n    ) external view returns (address[] memory) {\r\n        return smartContractWalletsOfAddress[_address];\r\n    }\r\n}"
      },
      "project/contracts/SmartContractWallet.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/// @title SmartContractWallet\r\n/// @author Rahul Mayekar (https://github.com/CrazzyPhoton)\r\n/// @notice A smart contract wallet that can hold and transfer ETH, ERC20, ERC721 and ERC1155 tokens.\r\n/// @dev Inherits ERC721Holder and ERC1155Holder to handle safe transfers of ERC721 and ERC1155 tokens.\r\n\r\ncontract SmartContractWallet is ERC721Holder, ERC1155Holder {\r\n    // STATE VARIABLES //\r\n\r\n    /// @notice Address variable to store owner.\r\n    address public owner;\r\n\r\n    /// @notice Address variable to store trusteeA.\r\n    address public trusteeA;\r\n\r\n    /// @notice Address variable to store trusteeB.\r\n    address public trusteeB;\r\n\r\n    /// @notice Address variable to store trusteeC.\r\n    address public trusteeC;\r\n\r\n    // EVENTS //\r\n\r\n    /// @notice Event emitted when ETH is transferred.\r\n    event EthTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    /// @notice Event emitted when trusteeA is set.\r\n    event NewTrusteeA(address indexed _trusteeA);\r\n\r\n    /// @notice Event emitted when trusteeB is set.\r\n    event NewTrusteeB(address indexed _trusteeB);\r\n\r\n    /// @notice Event emitted when trusteeC is set.\r\n    event NewTrusteeC(address indexed _trusteeC);\r\n\r\n    /// @notice Event emitted when ownership is transferred.\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    // ERRORS //\r\n\r\n    /// @notice Error thrown when caller is not owner.\r\n    error CallerNotOwner(address caller);\r\n\r\n    /// @notice Error thrown when caller is not owner nor trustee.\r\n    error CallerNotOwnerNorTrustee(address caller);\r\n\r\n    /// @notice Error thrown when ETH balance in contract is lesser than required.\r\n    error EthInsufficientBalance(uint256 ethBalance);\r\n\r\n    /// @notice Error thrown when inputted ETH amount is 0.\r\n    error InvalidEthAmount(uint256 ethAmount);\r\n\r\n    /// @notice Error thrown when new owner is zero address.\r\n    error InvalidNewOwner(address zeroAddress);\r\n\r\n    /// @notice Error thrown when recipient is zero address.\r\n    error InvalidRecipientAddress(address recipient);\r\n\r\n    /// @notice Error thrown when ETH withdrawal to recipient is unsuccessful.\r\n    error UnableToSendValue(address recipient);\r\n\r\n    // MODIFIERS //\r\n\r\n    /// @notice Modifier to check whether caller is owner.\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert CallerNotOwner(msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @notice Modifier to check whether caller is owner or trustee.\r\n    modifier onlyOwnerOrTrustee() {\r\n        if (\r\n            msg.sender != owner &&\r\n            msg.sender != trusteeA &&\r\n            msg.sender != trusteeB &&\r\n            msg.sender != trusteeC\r\n        ) {\r\n            revert CallerNotOwnerNorTrustee(msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCTOR //\r\n\r\n    /// @notice Constructor called during deployment.\r\n    constructor(\r\n        address _owner,\r\n        address _trusteeA,\r\n        address _trusteeB,\r\n        address _trusteeC\r\n    ) {\r\n        if (_owner == address(0)) {\r\n            revert InvalidNewOwner(address(0));\r\n        }\r\n        owner = _owner;\r\n        trusteeA = _trusteeA;\r\n        trusteeB = _trusteeB;\r\n        trusteeC = _trusteeC;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n        emit NewTrusteeA(_trusteeA);\r\n        emit NewTrusteeB(_trusteeB);\r\n        emit NewTrusteeC(_trusteeC);\r\n    }\r\n\r\n    // OWNER MANAGEMENT FUNCTIONS //\r\n\r\n    /**\r\n     * @notice Function transfers ownership of the smart contract to a new address.\r\n     *\r\n     * @param newOwner Address of new owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert InvalidNewOwner(address(0));\r\n        }\r\n        address oldOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    // TRUSTEE MANAGEMENT FUNCTIONS //\r\n\r\n    /**\r\n     * @notice Function sets address of trusteeA.\r\n     *\r\n     * @param _trusteeA Address of trusteeA.\r\n     */\r\n    function setTrusteeA(address _trusteeA) external onlyOwner {\r\n        trusteeA = _trusteeA;\r\n        emit NewTrusteeA(_trusteeA);\r\n    }\r\n\r\n    /**\r\n     * @notice Function sets address of trusteeB.\r\n     *\r\n     * @param _trusteeB Address of trusteeB.\r\n     */\r\n    function setTrusteeB(address _trusteeB) external onlyOwner {\r\n        trusteeB = _trusteeB;\r\n        emit NewTrusteeB(_trusteeB);\r\n    }\r\n\r\n    /**\r\n     * @notice Function sets address of trusteeC.\r\n     *\r\n     * @param _trusteeC Address of trusteeC.\r\n     */\r\n    function setTrusteeC(address _trusteeC) external onlyOwner {\r\n        trusteeC = _trusteeC;\r\n        emit NewTrusteeC(_trusteeC);\r\n    }\r\n\r\n    // ETH TRANSACTIONS FUNCTIONS //\r\n\r\n    /// @notice Function allows this contract to directly receive ETH.\r\n    receive() external payable virtual {\r\n        emit EthTransfer(msg.sender, address(this), msg.value);\r\n    }\r\n\r\n    /// @notice Function allows manually depositing ETH to this contract.\r\n    function depositEth() external payable {\r\n        emit EthTransfer(msg.sender, address(this), msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Function withdraws ETH from this contract and sends to recipient.\r\n     *         Smart contract owner only function.\r\n     *\r\n     * @param recipient The address of the recipient who will receive the ETH.\r\n     * @param ethAmount The ETH amount the recipient will receive.\r\n     */\r\n    function sendEth(\r\n        address payable recipient,\r\n        uint256 ethAmount\r\n    ) external onlyOwnerOrTrustee {\r\n        if (recipient == address(0)) {\r\n            revert InvalidRecipientAddress(recipient);\r\n        }\r\n        if (ethAmount == 0) {\r\n            revert InvalidEthAmount(ethAmount);\r\n        }\r\n        if (address(this).balance < ethAmount) {\r\n            revert EthInsufficientBalance(address(this).balance);\r\n        }\r\n        (bool success, ) = recipient.call{value: ethAmount}(\"\");\r\n        if (!success) {\r\n            revert UnableToSendValue(recipient);\r\n        }\r\n        emit EthTransfer(address(this), recipient, ethAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Function withdraws all ETH from this contract and sends to recipient.\r\n     *         Smart contract owner only function.\r\n     *\r\n     * @param recipient The address of the recipient who will receive the ETH.\r\n     */\r\n    function sendEthBalance(\r\n        address payable recipient\r\n    ) external onlyOwnerOrTrustee {\r\n        if (recipient == address(0)) {\r\n            revert InvalidRecipientAddress(recipient);\r\n        }\r\n        if (address(this).balance == 0) {\r\n            revert EthInsufficientBalance(address(this).balance);\r\n        }\r\n        uint256 balance = address(this).balance;\r\n        (bool success, ) = recipient.call{value: balance}(\"\");\r\n        if (!success) {\r\n            revert UnableToSendValue(recipient);\r\n        }\r\n        emit EthTransfer(address(this), recipient, balance);\r\n    }\r\n\r\n    // ERC20 TRANSACTIONS FUNCTIONS //\r\n\r\n    /**\r\n     * @notice Function allows this contract to receive erc20 tokens from the caller.\r\n     *         Caller needs to first approve this contract as a spender for the erc20 token amount they are sending to this contract using the approve function present on the erc20 token contract.\r\n     *\r\n     * @param token       The erc20 token contract address.\r\n     * @param tokenAmount The erc20 token amount which this contract will receive from the caller.\r\n     */\r\n    function depositErc20(IERC20 token, uint256 tokenAmount) external {\r\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Function withdraws erc20 token from this contract and sends to recipient.\r\n     *         Smart contract owner only function.\r\n     *\r\n     * @param recipient   The address of the recipient.\r\n     * @param token       The erc20 token contract address.\r\n     * @param tokenAmount The erc20 token amount to be sent to the recipient.\r\n     */\r\n    function sendErc20(\r\n        address recipient,\r\n        IERC20 token,\r\n        uint256 tokenAmount\r\n    ) external onlyOwnerOrTrustee {\r\n        SafeERC20.safeTransfer(token, recipient, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Function withdraws erc20 token balance from this contract and sends to recipient.\r\n     *         Smart contract owner only function.\r\n     *\r\n     * @param recipient The address of the recipient.\r\n     * @param token     The erc20 token contract address.\r\n     */\r\n    function sendErc20Balance(\r\n        address recipient,\r\n        IERC20 token\r\n    ) external onlyOwnerOrTrustee {\r\n        SafeERC20.safeTransfer(token, recipient, token.balanceOf(address(this)));\r\n    }\r\n\r\n    // ERC721 TRANSACTIONS FUNCTIONS //\r\n\r\n    /**\r\n     * @notice Function allows this contract to receive erc721 token from the caller.\r\n     *         Caller needs to first approve this contract as an operator for the erc721 token they are sending to this contract using the setApprovalForAll function present on the erc721 token contract.\r\n     *\r\n     * @param token   The erc721 token contract address.\r\n     * @param tokenId The erc721 token ID which the contract will receive from the caller.\r\n     */\r\n    function depositErc721(IERC721 token, uint256 tokenId) external {\r\n        token.safeTransferFrom(msg.sender, address(this), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Function withdraws erc721 token from this contract and sends to recipient.\r\n     *         Smart contract owner only function.\r\n     *\r\n     * @param recipient The address of the recipient.\r\n     * @param token     The erc721 token contract address.\r\n     * @param tokenId   The erc721 token ID to be sent to the recipient.\r\n     */\r\n    function sendErc721(\r\n        address recipient,\r\n        IERC721 token,\r\n        uint256 tokenId\r\n    ) external onlyOwnerOrTrustee {\r\n        token.safeTransferFrom(address(this), recipient, tokenId);\r\n    }\r\n\r\n    // ERC1155 TRANSACTIONS FUNCTIONS //\r\n\r\n    /**\r\n     * @notice Function allows this contract to receive erc1155 token from the caller.\r\n     *         Caller needs to first approve this contract as an operator for the erc1155 token they are sending to this contract using the setApprovalForAll function present on the erc1155 token contract.\r\n     *\r\n     * @param token         The erc1155 token contract address.\r\n     * @param tokenId       The erc1155 token ID.\r\n     * @param tokenIdAmount The erc1155 token ID amount the contract will receive from the caller.\r\n     */\r\n    function depositErc1155(\r\n        IERC1155 token,\r\n        uint256 tokenId,\r\n        uint256 tokenIdAmount\r\n    ) external {\r\n        token.safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            tokenId,\r\n            tokenIdAmount,\r\n            \"\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Function withdraws erc1155 token from this contract and sends to recipient.\r\n     *         Smart contract owner only function.\r\n     *\r\n     * @param recipient     The address of the recipient.\r\n     * @param token         The erc1155 token contract address.\r\n     * @param tokenId       The erc1155 token ID.\r\n     * @param tokenIdAmount The erc1155 token ID amount to be sent to the recipient.\r\n     */\r\n    function sendErc1155(\r\n        address recipient,\r\n        IERC1155 token,\r\n        uint256 tokenId,\r\n        uint256 tokenIdAmount\r\n    ) external onlyOwnerOrTrustee {\r\n        token.safeTransferFrom(\r\n            address(this),\r\n            recipient,\r\n            tokenId,\r\n            tokenIdAmount,\r\n            \"\"\r\n        );\r\n    }\r\n}"
      }
    }
  }
}